var adapter = require('webrtc-adapter');

var trace = require('./utils').trace;
var uuid = require('./utils').uuid;
var _str = require('./utils')._str;
var colours = require('./palette');

var Sync = require('./sync');

var servers = {
  iceServers: [
    {urls:'stun:stun01.sipphone.com'},
    {urls:'stun:stun.ekiga.net'},
    {urls:'stun:stun.fwdnet.net'},
    {urls:'stun:stun.ideasip.com'},
    {urls:'stun:stun.iptel.org'},
    {urls:'stun:stun.rixtelecom.se'},
    {urls:'stun:stun.schlund.de'},
    {urls:'stun:stun.l.google.com:19302'},
    {urls:'stun:stun1.l.google.com:19302'},
    {urls:'stun:stun2.l.google.com:19302'},
    {urls:'stun:stun3.l.google.com:19302'},
    {urls:'stun:stun4.l.google.com:19302'},
    {urls:'stun:stunserver.org'},
    {urls:'stun:stun.softjoys.com'},
    {urls:'stun:stun.voiparound.com'},
    {urls:'stun:stun.voipbuster.com'},
    {urls:'stun:stun.voipstunt.com'},
    {urls:'stun:stun.voxgratia.org'},
    {urls:'stun:stun.xten.com'},
    {
    	urls: 'turn:numb.viagenie.ca',
    	credential: 'muazkh',
    	username: 'webrtc@live.com'
    },
    {
    	urls: 'turn:192.158.29.39:3478?transport=udp',
    	credential: 'JZEOEt2V3Qb0y27GRntt2u2PAYA=',
    	username: '28224511:1379330808'
    },
    {
    	urls: 'turn:192.158.29.39:3478?transport=tcp',
    	credential: 'JZEOEt2V3Qb0y27GRntt2u2PAYA=',
    	username: '28224511:1379330808'
    },
  ]
};

var RTCPConnect = (function(window) {
  var uid = uuid();
  var peers = {};
  var pcConstraint = null;
  var dataConstraint = null;
  var connectionId;
  var usedColours = [];

  /**
   * Initialize function
   * @param  {String} cId - connection ID
   */
  function init(cId) {
    window.peers = peers;
    window.uid = uid;

    connectionId = cId;
  }

  /**
   * Create new connection.
   * @param  {String} toUid             recipient uid stored on server
   * @return {RTCPeerConnection}        new PeerConnection
   */
  function createConnection(toUid) {
    var userColour = _.sample(_.difference(colours, usedColours));
    usedColours[usedColours.length] = userColour;

    trace('Using SCTP based data channels');
    var connection = new RTCPeerConnection(servers, pcConstraint);

    connection.ondatachannel = function(event) {
      return _receiveChannelCallback(event, toUid);
    };

    if (uid !== toUid) {
      connection.onicecandidate = function(event) {
        return _onIceCandidate(event, toUid);
      };
    }

    peers[toUid] = {};
    peers[toUid].connection = connection;
    peers[toUid].colour = userColour;

    trace('Created local peer connection object localConnection');
    return connection;
  }

  /**
   * Create new channel
   * @param  {String} toUid    recipient connection uid
   * @param {String} channelId channel unique Id
   * @return {RTCDataChannel}  new data channel
   */
  function createChannel(toUid, channelId) {
    channelId = typeof channelId !== 'undefined' ? channelId : toUid;

    var connection = peers[toUid].connection;
    var channel = connection.createDataChannel(channelId, dataConstraint);
    channel.binaryType = 'arraybuffer';
    trace('Created send data channel with id: ' + channelId);

    if (arguments.length > 1) {
      peers[toUid][channelId] = channel;
    } else {
      peers[toUid].channel = channel;
    }


    _bindChannelEvents(channel);

    return channel;
  }

  /**
   * Create RTCOffer
   * @param  {String} toUid             recipient uid stored on server
   */
  function createOffer(toUid) {
    var connection = peers[toUid].connection;

    connection.createOffer().then(
      function(offer) {
        connection.setLocalDescription(offer);
        Sync.trigger('ws:send', _str({
          type: 'offer',
          fromUid: uid,
          toUid: toUid,
          offer: _str(offer.toJSON()),
        }));
      },
      _onCreateSessionDescriptionError
    );
  }

  /**
   * Handle offer
   * @param  {Object} message - offer message
   */
  function handleOffer(message) {
    var offer = new RTCSessionDescription(JSON.parse(message.offer));

    // need to switch UIDs here
    var _connection = createConnection(message.fromUid);

    _connection.setRemoteDescription(offer);

    _connection.createAnswer().then(
      function(answer) {
        _connection.setLocalDescription(answer);
        Sync.trigger('ws:send', _str({
          type: 'answer',
          fromUid: uid,
          toUid: message.fromUid,
          answer: _str(answer.toJSON()),
        }));
      },
      _onCreateSessionDescriptionError
    );
  }

  /**
   * Answer handler
   * @param  {Object} message answer message
   */
  function handleAnswer(message) {
    var connection = peers[message.fromUid].connection;

    var answer = new RTCSessionDescription(JSON.parse(message.answer));
    connection.setRemoteDescription(answer);
  }

  function handleIceCandidate(message) {
    var connection = peers[message.fromUid].connection;
    connection.addIceCandidate(new RTCIceCandidate(JSON.parse(message.iceCandidate)));
  }

  /**
   * Handle local ice candidate
   * @param  {Event} event        iceCandidate event
   * @param  {String} toUid       recipient uid stored on server
   */
  function _onIceCandidate(event, toUid) {
    trace('local ice callback');
    if (event.candidate) {
      Sync.trigger('ws:send', _str({
        type: 'iceCandidate',
        fromUid: uid,
        toUid: toUid,
        iceCandidate: _str(event.candidate.toJSON()),
      }));
    }
  }

  /**
   * channel callback handler
   * @param  {Event} event  channel event
   * @param  {String} toUid recipient connection uid stored on server
   */
  function _receiveChannelCallback(event, toUid) {
    trace('Receive Channel Callback');
    var channel = event.channel;
    channel.binaryType = 'arraybuffer';

    if (!peers[toUid].channel) {
      peers[toUid].channel = channel;
    } else {
      peers[toUid][channel.label] = channel;
    }

    _bindChannelEvents(channel);
  }

  /**
   * Bind channel events helper function
   * @param  {RTCDataChannel} channel RTC data channel
   */
  function _bindChannelEvents(channel) {
    channel.onopen = function() {return _onSendChannelStateChange(channel);};
    channel.onclose = function() {return _onSendChannelStateChange(channel);};

    channel.onmessage = function(event) {
      if (typeof event.data === 'string') {
        if (event.data.indexOf('__fileDescription') > -1) {
          Sync.trigger('load:start');
          event.target['__fileDescription'] = JSON.parse(event.data.split('::')[1]);
        } else if (event.data.indexOf('__fileTransferComplete') > -1) {
          if (event.target._receiveBuffer) {
            var received = new window.Blob(event.target._receiveBuffer, {type: event.target.__fileDescription.type});
            var href = URL.createObjectURL(received);
            var message = JSON.parse(event.data.split('::')[1]);

            Sync.trigger('message', {
              type: 'file',
              data: href,
              __fileDescription: channel.__fileDescription || {},
              colour: peers[message.fromUid] ?
                peers[message.fromUid].colour : '#ccc',
            });
            Sync.trigger('load:complete');
          }
        } else if (event.data.indexOf('__progress') > -1) {
          Sync.trigger('load:progress', event.data.split('::')[1]);
        } else {
          var message = JSON.parse(event.data);

          Sync.trigger('message', {
            colour: peers[message.fromUid] ?
              peers[message.fromUid].colour : '#ccc',
            type: message.type,
            data: message.data,
          });
        }
      } else if (event.data instanceof ArrayBuffer) {
        event.target._receiveBuffer = event.target._receiveBuffer || [];
        event.target._receiveBuffer.push(event.data);
      }
    };
  }

  /**
   * channel state change handler
   * @param  {RTCDataChannel} channel RTCDataChannel
   */
  function _onSendChannelStateChange(channel) {
    trace('Send channel state is: ' + channel.readyState);

    if (channel.readyState === 'open') {
      Sync.trigger('channelOpen', channel);
    } else if (channel.readyState === 'closed') {
      _.each(peers, function(peer, key) {
        if (peer[channel.label])
          delete peer[channel.label];
      });
    }
  }

  /**
   * _onCreateSessionDescriptionError helper function
   * @param  {Error} error Error
   */
  function _onCreateSessionDescriptionError(error) {
    trace('Failed to create session description: ' + error.toString());
  }

  /**
   * Drop connection.
   * @param  {String} toUid connection uid
   */
  function dropConnection(toUid) {
    var connection = peers[toUid].connection;
    var channel = peers[toUid].channel;

    if (channel) channel.close();
    if (connection) connection.close();
    delete peers[toUid];
    if (_.size(peers) === 0) Sync.trigger('channelClose');
  }

  return {
    init: init,
    createConnection: createConnection,
    createChannel: createChannel,
    createOffer: createOffer,
    handleOffer: handleOffer,
    handleAnswer: handleAnswer,
    handleIceCandidate: handleIceCandidate,
    dropConnection: dropConnection,
    getUid: function() {
      return uid;
    },
    getPeers: function() {
      return peers;
    },
  };
})(window);

module.exports = RTCPConnect;
